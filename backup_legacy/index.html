<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Máquina de Turing</title>
    
    <!-- Favicon (SVG Data URI) -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%234f46e5' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Crect x='4' y='4' width='16' height='16' rx='2' ry='2'/%3E%3Crect x='9' y='9' width='6' height='6'/%3E%3Cline x1='9' y1='1' x2='9' y2='4'/%3E%3Cline x1='15' y1='1' x2='15' y2='4'/%3E%3Cline x1='9' y1='20' x2='9' y2='23'/%3E%3Cline x1='15' y1='20' x2='15' y2='23'/%3E%3Cline x1='20' y1='9' x2='23' y2='9'/%3E%3Cline x1='20' y1='14' x2='23' y2='14'/%3E%3Cline x1='1' y1='9' x2='4' y2='9'/%3E%3Cline x1='1' y1='14' x2='4' y2='14'/%3E%3C/svg%3E" type="image/svg+xml">

    <!-- Bibliotecas Externas -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.min.js"></script>

    <!-- Fontes -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Estilos Globais -->
    <style>
        :root {
            --tape-size: 56px;
        }
        body { font-family: 'Inter', sans-serif; touch-action: none; overscroll-behavior: none; }
        .font-mono { font-family: 'JetBrains Mono', monospace; }
        
        /* Otimização de animação da fita */
        .tape-container { will-change: transform; }
        .tape-cell { width: var(--tape-size); height: var(--tape-size); transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1); }
        
        .needs-compile { animation: pulse-border 2s infinite; }
        @keyframes pulse-border {
            0% { box-shadow: 0 0 0 0 rgba(99, 102, 241, 0.4); }
            70% { box-shadow: 0 0 0 6px rgba(99, 102, 241, 0); }
            100% { box-shadow: 0 0 0 0 rgba(99, 102, 241, 0); }
        }
        
        /* Mermaid Fixes para iPad */
        .edgeLabel { background-color: white; opacity: 0.95; padding: 2px; }
        g.edgeLabel > g > foreignObject > div { background-color: white; }
        
        /* Scrollbar customizada */
        .custom-scroll::-webkit-scrollbar { width: 6px; }
        .custom-scroll::-webkit-scrollbar-track { background: #f1f5f9; }
        .custom-scroll::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        .custom-scroll::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
    </style>
</head>
<body class="bg-slate-50 text-slate-900 overflow-hidden h-screen w-screen selection:bg-indigo-100 selection:text-indigo-700">

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo, memo } = React;

        // ==========================================
        // CONFIGURAÇÕES GLOBAIS
        // ==========================================
        const CONFIG = {
            MAX_HISTORY: 2000,
            MAX_BATCH_STEPS: 5000,
            TAPE_CELL_WIDTH: 56,
            TAPE_CELL_MARGIN: 8,
            SYNTAX_REGEX: /^(\w+)\s+([^\s\/]+)\s*\/\s*([^\s,]+)\s*,\s*([RLS])\s+(\w+)$/
        };

        const THEME = {
            primary: '#ea580c', // Laranja
            success: '#10b981', // Verde
            error:   '#ef4444', // Vermelho
            stroke:  '#94a3b8', // Cinza
            text:    '#312e81'  // Indigo
        };

        const DEFAULT_CODE = `// Inversor de Bits (0 <-> 1)
// Sintaxe: EstadoAtual  Lido/Escrito,Dir  ProxEstado

q0  0/1,R  q0
q0  1/0,R  q0
q0  _/_,S  ha`;

        const SUBSCRIPT_MAP = {
            '0': '₀', '1': '₁', '2': '₂', '3': '₃', '4': '₄',
            '5': '₅', '6': '₆', '7': '₇', '8': '₈', '9': '₉',
            'a': 'ₐ', 'e': 'ₑ', 'h': 'ₕ', 'i': 'ᵢ', 'k': 'ₖ',
            'l': 'ₗ', 'm': 'ₘ', 'n': 'ₙ', 'o': 'ₒ', 'p': 'ₚ',
            'r': 'ᵣ', 's': 'ₛ', 't': 'ₜ', 'u': 'ᵤ', 'v': 'ᵥ', 'x': 'ₓ'
        };

        // ==========================================
        // UTILS (Lógica Pura - Separada da UI)
        // ==========================================

        const formatStateLabel = (name) => {
            if (name === 'ha') return 'hₐ';
            const match = name.match(/^([a-zA-Z])(\w+)$/);
            if (match) {
                const base = match[1];
                const sub = match[2].split('').map(c => SUBSCRIPT_MAP[c] || c).join('');
                return `${base}${sub}`;
            }
            return name;
        };

        const parseMachineCode = (sourceCode) => {
            const lines = sourceCode.split('\n');
            const newTransitions = {};
            const nodes = new Set();
            const rawEdges = []; 
            const errors = []; 

            lines.forEach((line, index) => {
                const trimmed = line.trim();
                if (!trimmed || /^(?:\/\/|#|;)/.test(trimmed)) return;

                const match = trimmed.match(CONFIG.SYNTAX_REGEX);

                if (match) {
                    const [, from, read, write, move, to] = match;
                    nodes.add(from);
                    nodes.add(to);
                    
                    const rVis = read === '_' ? 'Δ' : read;
                    const wVis = write === '_' ? 'Δ' : write;
                    const label = `${rVis}/${wVis}, ${move}`;
                    const key = `${from}:${read}`;
                    
                    if (newTransitions[key]) {
                        errors.push(`Linha ${index + 1}: Conflito de regras para estado '${from}' lendo '${read}'.`);
                    }

                    newTransitions[key] = { from, write, move, to, label };
                    rawEdges.push({ from, to, label });
                } else {
                    errors.push(`Linha ${index + 1}: Sintaxe inválida. Esperado: "q0  _/_,R  q1"`);
                }
            });

            if (errors.length > 0) throw new Error(errors[0]);

            // Agrupa arestas visuais
            const edgeMap = new Map();
            rawEdges.forEach(edge => {
                const key = `${edge.from}|${edge.to}`;
                if (!edgeMap.has(key)) {
                    edgeMap.set(key, { from: edge.from, to: edge.to, labels: [] });
                }
                edgeMap.get(key).labels.push(edge.label);
            });

            const edges = Array.from(edgeMap.values());
            const edgeIndexMap = new Map();
            edges.forEach((edge, idx) => edgeIndexMap.set(`${edge.from}|${edge.to}`, idx));

            // Associa índice visual à regra lógica
            Object.values(newTransitions).forEach(t => {
                const edgeKey = `${t.from}|${t.to}`;
                if (edgeIndexMap.has(edgeKey)) {
                    t.edgeIndex = edgeIndexMap.get(edgeKey);
                }
            });

            return { newTransitions, nodes: Array.from(nodes), edges };
        };

        const runFastSimulation = (transitions, inputString) => {
            const tape = {};
            for (let i = 0; i < inputString.length; i++) tape[i] = inputString[i];
            
            let head = 0;
            let currentState = 'q0'; 
            let steps = 0;

            while (steps < CONFIG.MAX_BATCH_STEPS) {
                if (currentState === 'ha') return 'ACCEPTED';

                const currentSymbol = tape[head] || '_';
                const key = `${currentState}:${currentSymbol}`;
                const rule = transitions[key];

                if (!rule) return 'REJECTED';

                if (rule.write === '_') delete tape[head];
                else tape[head] = rule.write;

                if (rule.move === 'R') head++;
                else if (rule.move === 'L') head--;

                if (head < 0) return 'REJECTED'; // Crash (Limite esquerdo)

                currentState = rule.to;
                steps++;
            }
            return 'TIMEOUT';
        };

        const generateMermaidDefinition = (nodes, edges, currentState, status, activeEdgeIndex) => {
            let def = 'flowchart LR\n';
            nodes.forEach(node => {
                const label = formatStateLabel(node);
                const shapeStart = node === 'ha' ? '((("' : '(["';
                const shapeEnd = node === 'ha' ? '")))' : '"])';
                def += `    ${node}${shapeStart}${label}${shapeEnd}\n`;
            });
            edges.forEach(edge => {
                const combined = edge.labels.join('\n');
                def += `    ${edge.from} -->|"${combined}"| ${edge.to}\n`;
            });

            if (status === 'ACCEPTED') def += `\n    style ${currentState} fill:${THEME.success},stroke:${THEME.success},color:white,stroke-width:2px`;
            else if (status === 'REJECTED') def += `\n    style ${currentState} fill:${THEME.error},stroke:${THEME.error},color:white,stroke-width:2px`;
            else def += `\n    style ${currentState} fill:${THEME.primary},stroke:#c2410c,color:white,stroke-width:3px`;

            if (activeEdgeIndex !== null) def += `\n    linkStyle ${activeEdgeIndex} stroke:${THEME.primary},stroke-width:3px;`;
            else def += `\n    linkStyle default stroke:${THEME.stroke},stroke-width:1px;`;

            return def;
        };

        /**
         * Manipulação segura do DOM SVG para colorir elementos específicos.
         * Suporta HTML Labels = false (iPad/Safari fix)
         */
        const applySvgPostProcessing = (container, activeColor, activeEdgeIndex, activeRuleLabel) => {
            const svgElem = container.querySelector('svg');
            if (!svgElem) return;
            
            // Fix zoom bug em SVG
            svgElem.style.maxWidth = 'none';
            svgElem.style.height = '100%';

            // 1. Colorir Arrowheads (Marcadores)
            const links = svgElem.querySelectorAll('path');
            links.forEach(link => {
                const style = link.getAttribute('style') || '';
                // Verifica se é a linha ativa (Mermaid coloca a cor inline)
                if (style.includes(activeColor) || style.includes('rgb(234, 88, 12)')) {
                    const markerUrl = link.getAttribute('marker-end');
                    if (markerUrl) {
                        const markerIdMatch = markerUrl.match(/#([^"')\)]+)/);
                        if (markerIdMatch && markerIdMatch[1]) {
                            const markerId = markerIdMatch[1];
                            const originalMarker = svgElem.getElementById(markerId);
                            if (originalMarker) {
                                // Cria um ID único para não afetar outros marcadores
                                const newMarkerId = markerId + '-active-' + Date.now();
                                const newMarker = originalMarker.cloneNode(true);
                                newMarker.setAttribute('id', newMarkerId);
                                newMarker.querySelectorAll('path, circle, polygon').forEach(p => {
                                    p.setAttribute('fill', activeColor);
                                    p.setAttribute('stroke', activeColor);
                                });
                                originalMarker.parentNode.appendChild(newMarker);
                                link.setAttribute('marker-end', `url(#${newMarkerId})`);
                            }
                        }
                    }
                }
            });

            // 2. Colorir o texto específico da regra ativa
            if (activeEdgeIndex !== null && activeRuleLabel) {
                const edgeLabels = svgElem.querySelectorAll('.edgeLabel');
                if (edgeLabels[activeEdgeIndex]) {
                    const labelGroup = edgeLabels[activeEdgeIndex];
                    const tspans = labelGroup.querySelectorAll('tspan');
                    tspans.forEach(tspan => {
                        if (tspan.textContent.trim() === activeRuleLabel.trim()) {
                            tspan.setAttribute('fill', activeColor);
                            tspan.setAttribute('font-weight', 'bold');
                            tspan.style.fill = activeColor;
                            tspan.style.fontWeight = 'bold';
                        }
                    });
                }
            }
        };

        // ==========================================
        // COMPONENTES UI (Memoizados para Performance)
        // ==========================================

        const Icons = {
            Play: (props) => <svg {...props} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg>,
            Pause: (props) => <svg {...props} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>,
            SkipForward: (props) => <svg {...props} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 4 15 12 5 20 5 4"/><line x1="19" y1="5" x2="19" y2="19"/></svg>,
            SkipBack: (props) => <svg {...props} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="19 20 9 12 19 4 19 20"/><line x1="5" y1="19" x2="5" y2="5"/></svg>,
            RotateCcw: (props) => <svg {...props} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>,
            CheckCircle2: (props) => <svg {...props} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><path d="m9 12 2 2 4-4"/></svg>,
            XCircle: (props) => <svg {...props} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><path d="m15 9-6 6"/><path d="m9 9 6 6"/></svg>,
            AlertCircle: (props) => <svg {...props} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>,
            TriangleDown: (props) => <svg {...props} width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M0 0L10 10L20 0H0Z" /></svg>,
            Cpu: (props) => <svg {...props} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="4" y="4" width="16" height="16" rx="2" ry="2"/><rect x="9" y="9" width="6" height="6"/><line x1="9" y1="1" x2="9" y2="4"/><line x1="15" y1="1" x2="15" y2="4"/><line x1="9" y1="20" x2="9" y2="23"/><line x1="15" y1="20" x2="15" y2="23"/><line x1="20" y1="9" x2="23" y2="9"/><line x1="20" y1="14" x2="23" y2="14"/><line x1="1" y1="9" x2="4" y2="9"/><line x1="1" y1="14" x2="4" y2="14"/></svg>,
            Code: (props) => <svg {...props} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg>,
            Terminal: (props) => <svg {...props} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="4 17 10 11 4 5"></polyline><line x1="12" y1="19" x2="20" y2="19"></line></svg>,
            PlayPlay: (props) => <svg {...props} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg>,
            Plus: (props) => <svg {...props} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>,
            Trash: (props) => <svg {...props} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>,
            Eye: (props) => <svg {...props} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>,
            InputLoad: (props) => <svg {...props} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="19" x2="12" y2="5"/><polyline points="5 12 12 5 19 12"/></svg>,
            ChevronLeft: (props) => <svg {...props} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="15 18 9 12 15 6" /></svg>,
            ChevronRight: (props) => <svg {...props} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="9 18 15 12 9 6" /></svg>,
            PanelLeft: (props) => <svg {...props} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="18" height="18" x="3" y="3" rx="2" ry="2" /><line x1="9" x2="9" y1="3" y2="21" /></svg>,
            PanelRight: (props) => <svg {...props} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="18" height="18" x="3" y="3" rx="2" ry="2" /><line x1="15" x2="15" y1="3" y2="21" /></svg>
        };

        const Header = memo(({ status, runtimeError, currentState, head, stepCount, activeInput }) => (
            <div className="flex flex-col bg-white shadow-sm z-20 border-b border-slate-200 shrink-0">
                <div className="flex items-center justify-between px-6 py-3 bg-slate-50">
                    <div className="flex items-center gap-3">
                        <div className="bg-indigo-600 text-white p-1.5 rounded-lg shadow-sm">
                            <Icons.Cpu size={20} />
                        </div>
                        <h1 className="text-lg font-bold text-slate-800 tracking-tight">TM Simulator</h1>
                    </div>
                    <div className="flex items-center gap-4">
                        <div className="text-xs text-slate-500 font-mono bg-white px-3 py-1 rounded-full border border-slate-200 shadow-sm flex gap-3">
                            <span className="font-bold text-slate-400 uppercase tracking-wider text-[10px] mr-1">Entrada Atual:</span>
                            <span className="text-slate-800 font-medium">{activeInput || "Vazio"}</span>
                        </div>
                        <div className="h-6 w-px bg-slate-300 mx-1"></div>
                        <div className="flex items-center gap-3">
                            {status === 'ACCEPTED' && <span className="flex items-center gap-2 text-emerald-700 font-bold px-3 py-1 bg-emerald-100 border border-emerald-200 rounded-full text-xs animate-in fade-in"><Icons.CheckCircle2 size={16}/> ACEITA</span>}
                            {status === 'REJECTED' && <span className="flex items-center gap-2 text-rose-700 font-bold px-3 py-1 bg-rose-100 border border-rose-200 rounded-full text-xs animate-in fade-in"><Icons.XCircle size={16}/> REJEITADA</span>}
                            {runtimeError && <span className="flex items-center gap-2 text-rose-600 text-xs font-medium bg-white px-3 py-1 rounded-full border border-rose-200 shadow-sm"><Icons.AlertCircle size={14}/> {runtimeError}</span>}
                            
                            <div className="text-xs text-slate-500 font-mono bg-white px-3 py-1 rounded-full border border-slate-200 shadow-sm flex gap-3">
                                <span>Q: <b className="text-indigo-600">{currentState}</b></span>
                                <span>H: <b className="text-indigo-600">{head}</b></span>
                                <span>Steps: <b className="text-indigo-600">{stepCount}</b></span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        ));

        const TapeVisualizer = memo(({ tape, head, status, onCellClick }) => {
            const TOTAL_CELL_WIDTH = CONFIG.TAPE_CELL_WIDTH + CONFIG.TAPE_CELL_MARGIN;
            const CENTER_OFFSET = TOTAL_CELL_WIDTH / 2;

            return (
                <div className="relative w-full bg-slate-100/50 h-28 border-b border-slate-200 shadow-inner overflow-hidden">
                    <div className="absolute left-0 top-0 bottom-0 w-24 z-20 bg-gradient-to-r from-slate-100 to-transparent pointer-events-none"/>
                    <div className="absolute right-0 top-0 bottom-0 w-24 z-20 bg-gradient-to-l from-slate-100 to-transparent pointer-events-none"/>
                    <div className="absolute top-0 left-1/2 -translate-x-1/2 z-30 text-indigo-500 drop-shadow-md mt-1">
                        <Icons.TriangleDown width="24" height="12" />
                    </div>
                    <div 
                        className="flex items-center h-full absolute top-0 left-1/2 transition-transform duration-300 ease-in-out tape-container"
                        style={{ transform: `translateX(calc(-${head * TOTAL_CELL_WIDTH}px - ${CENTER_OFFSET}px))` }}
                    >
                        {Array.from({ length: Math.max(head + 15, 30) }).map((_, idx) => {
                            const char = tape[idx] || '_';
                            const isHead = idx === head;
                            let stateStyle = "border-slate-300 bg-white text-slate-400";
                            if (isHead) {
                                if (status === 'REJECTED') stateStyle = "border-rose-500 bg-rose-50 text-rose-700 shadow-lg shadow-rose-200/50 scale-110";
                                else if (status === 'ACCEPTED') stateStyle = "border-emerald-500 bg-emerald-50 text-emerald-700 shadow-lg shadow-emerald-200/50 scale-110";
                                else stateStyle = "border-indigo-500 bg-white text-indigo-700 shadow-xl shadow-indigo-200/50 scale-110";
                            }
                            return (
                                <div 
                                    key={idx} 
                                    onClick={() => onCellClick(idx)}
                                    className="flex flex-col items-center justify-center shrink-0 mr-2 cursor-pointer hover:scale-105 transition-transform" 
                                    style={{ width: `${CONFIG.TAPE_CELL_WIDTH}px` }}
                                >
                                    <div className={`tape-cell rounded-xl flex items-center justify-center text-2xl font-mono font-medium border-2 ${stateStyle}`}>
                                        {char === '_' ? <span className="opacity-20">Δ</span> : char}
                                    </div>
                                    <div className={`text-[10px] mt-2 font-mono transition-colors ${isHead ? 'text-indigo-600 font-bold' : 'text-slate-300'}`}>{idx}</div>
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        });

        // --- COLUNA 1: EDITOR (COLAPSÁVEL - MODIFICADO) ---
        const EditorPanel = memo(({ editorCode, setEditorCode, onCompile, isDirty, compileError, isOpen, onToggle }) => {
            const statusUI = useMemo(() => {
                if (isDirty) return { color: "bg-amber-400", text: "Não compilado", textClass: "text-amber-600" };
                if (compileError) return { color: "bg-rose-500", text: "Erro", textClass: "text-rose-600" };
                return { color: "bg-emerald-500", text: "Compilado", textClass: "text-emerald-600" };
            }, [isDirty, compileError]);

            if (!isOpen) {
                return (
                    <div className="relative z-20 w-0 transition-all duration-300">
                        <button 
                            onClick={onToggle} 
                            className="absolute top-3 left-3 p-2 bg-white/90 backdrop-blur border border-slate-200 shadow-md text-slate-500 hover:text-indigo-600 rounded-lg transition" 
                            title="Abrir Editor"
                        >
                            <Icons.PanelLeft size={20}/>
                        </button>
                    </div>
                );
            }

            return (
                <div className="w-[25%] min-w-[300px] bg-white border-r border-slate-200 flex flex-col z-10 transition-all duration-300">
                    <div className="flex-1 flex flex-col relative group bg-slate-50 overflow-hidden">
                        <div className="flex items-center justify-between px-4 py-2 bg-slate-100 border-b border-slate-200">
                            <span className="text-[10px] font-bold uppercase text-slate-400 tracking-wider flex items-center gap-2"><Icons.Terminal size={12}/> Editor</span>
                            <div className="flex items-center gap-2">
                                {isDirty && <span className="text-[10px] font-bold text-amber-600 bg-amber-50 px-2 py-0.5 rounded-full border border-amber-100">Não Salvo</span>}
                                <button onClick={onToggle} className="text-slate-400 hover:text-indigo-600 transition" title="Minimizar"><Icons.ChevronLeft size={16}/></button>
                            </div>
                        </div>
                        <textarea value={editorCode} onChange={(e) => setEditorCode(e.target.value)} className="flex-1 w-full p-6 font-mono text-sm resize-none focus:outline-none bg-slate-50 text-slate-700 leading-relaxed" spellCheck="false"/>
                        <div className="bg-white px-5 py-3 text-[10px] border-t border-slate-100 font-mono flex items-center gap-2 overflow-hidden">
                            <span className={`w-2 h-2 rounded-full shrink-0 transition-colors duration-300 ${statusUI.color}`}></span>
                            <span className={`truncate transition-colors duration-300 ${statusUI.textClass}`} title={compileError || statusUI.text}>
                                {compileError ? compileError : statusUI.text}
                            </span>
                        </div>
                    </div>
                    <div className="p-4 bg-white border-t border-slate-200 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.05)] z-20">
                        <button onClick={onCompile} aria-label="Compilar Código" className={`w-full py-3 rounded-lg text-sm font-bold tracking-wide uppercase transition-all shadow-md active:scale-[0.98] flex items-center justify-center gap-2 ${isDirty ? 'bg-indigo-600 hover:bg-indigo-700 text-white needs-compile shadow-indigo-200' : 'bg-slate-800 hover:bg-slate-900 text-slate-200'}`}>
                            <Icons.Code size={18} /> Compilar
                        </button>
                    </div>
                </div>
            );
        });

        // --- COLUNA 3: PAINEL DE TESTES (COLAPSÁVEL - MODIFICADO) ---
        const TestPanel = ({ tests, onAddTest, onRemoveTest, onUpdateTestInput, onRunTests, onLoadTest, isRunningBatch, isOpen, onToggle }) => {
            if (!isOpen) {
                return (
                    <div className="relative z-20 w-0 transition-all duration-300">
                         <button 
                            onClick={onToggle} 
                            className="absolute top-3 right-3 p-2 bg-white/90 backdrop-blur border border-slate-200 shadow-md text-slate-500 hover:text-indigo-600 rounded-lg transition" 
                            title="Abrir Testes"
                        >
                            <Icons.PanelRight size={20}/>
                        </button>
                    </div>
                );
            }

            return (
                <div className="w-[25%] min-w-[300px] bg-white border-l border-slate-200 flex flex-col z-10 h-full transition-all duration-300">
                    <div className="flex items-center justify-between px-4 py-3 bg-slate-50 border-b border-slate-200">
                        <div className="flex items-center gap-2">
                             <button onClick={onToggle} className="text-slate-400 hover:text-indigo-600 transition" title="Minimizar"><Icons.ChevronRight size={16}/></button>
                            <h2 className="text-sm font-bold text-slate-700 flex items-center gap-2">
                                <Icons.CheckCircle2 size={16} className="text-slate-400"/> Casos de Teste
                            </h2>
                        </div>
                        <button onClick={onRunTests} disabled={isRunningBatch} className="text-xs bg-emerald-600 hover:bg-emerald-700 text-white px-3 py-1.5 rounded-md font-medium transition flex items-center gap-1 shadow-sm disabled:opacity-50">
                            <Icons.PlayPlay size={14}/> {isRunningBatch ? 'Rodando...' : 'Executar Todos'}
                        </button>
                    </div>
                    <div className="flex-1 overflow-y-auto p-2 space-y-2 bg-slate-50/50 custom-scroll">
                        {tests.map((test, index) => (
                            <div key={test.id} className="bg-white border border-slate-200 rounded-lg p-3 shadow-sm hover:shadow-md transition-shadow group">
                                <div className="flex items-center gap-2 mb-2">
                                    <div className="flex-1 flex items-center gap-2">
                                        <span className="text-[10px] font-mono text-slate-400 w-4">#{index + 1}</span>
                                        <input 
                                            type="text" 
                                            value={test.input}
                                            onChange={(e) => onUpdateTestInput(test.id, e.target.value)}
                                            placeholder="Entrada vazia"
                                            className="flex-1 text-sm font-mono bg-slate-50 border border-slate-200 rounded px-2 py-1 focus:ring-1 focus:ring-indigo-500 outline-none text-slate-700"
                                        />
                                    </div>
                                    <button onClick={() => onRemoveTest(test.id)} className="text-slate-300 hover:text-rose-500 transition"><Icons.Trash size={14}/></button>
                                </div>
                                <div className="flex items-center justify-between">
                                    <div className="flex items-center gap-2">
                                        {test.status === 'IDLE' && <span className="text-[10px] text-slate-400 bg-slate-100 px-2 py-0.5 rounded">Pendente</span>}
                                        {test.status === 'ACCEPTED' && <span className="flex items-center gap-1 text-[10px] text-emerald-700 bg-emerald-100 px-2 py-0.5 rounded font-bold"><Icons.CheckCircle2 size={12}/> Aceito</span>}
                                        {test.status === 'REJECTED' && <span className="flex items-center gap-1 text-[10px] text-rose-700 bg-rose-100 px-2 py-0.5 rounded font-bold"><Icons.XCircle size={12}/> Rejeitado</span>}
                                        {test.status === 'TIMEOUT' && <span className="flex items-center gap-1 text-[10px] text-amber-700 bg-amber-100 px-2 py-0.5 rounded font-bold"><Icons.AlertCircle size={12}/> Timeout</span>}
                                    </div>
                                    <button 
                                        onClick={() => onLoadTest(test.input)}
                                        className="text-[10px] text-indigo-600 hover:bg-indigo-50 px-2 py-1 rounded transition flex items-center gap-1"
                                        title="Carregar no simulador"
                                    >
                                        <Icons.Eye size={12}/> Debug
                                    </button>
                                </div>
                            </div>
                        ))}
                    </div>
                    <div className="p-3 border-t border-slate-200 bg-white">
                        <button onClick={onAddTest} className="w-full border border-dashed border-slate-300 hover:border-indigo-400 hover:bg-indigo-50 text-slate-500 hover:text-indigo-600 py-2 rounded-lg text-xs font-medium transition flex items-center justify-center gap-2">
                            <Icons.Plus size={14}/> Adicionar Caso de Teste
                        </button>
                    </div>
                </div>
            );
        };

        const DiagramVisualizer = ({ visualData, currentState, transitions, status, compileError, tape, head }) => {
            const containerRef = useRef(null);
            const diagramRef = useRef(null);
            const [transform, setTransform] = useState({ x: 0, y: 0, scale: 1 });
            const isDragging = useRef(false);
            const lastPos = useRef({ x: 0, y: 0 });
            const lastDist = useRef(null);

            const handleWheel = (e) => {
                e.preventDefault();
                if (!containerRef.current) return;
                const rect = containerRef.current.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = Math.min(Math.max(0.2, transform.scale * delta), 4);
                const newX = mouseX - (mouseX - transform.x) * (newScale / transform.scale);
                const newY = mouseY - (mouseY - transform.y) * (newScale / transform.scale);
                setTransform({ x: newX, y: newY, scale: newScale });
            };

            const handleMouseDown = (e) => { isDragging.current = true; lastPos.current = { x: e.clientX, y: e.clientY }; };
            const handleMouseUp = () => { isDragging.current = false; };
            const handleMouseMove = (e) => {
                if (!isDragging.current) return;
                const dx = e.clientX - lastPos.current.x;
                const dy = e.clientY - lastPos.current.y;
                lastPos.current = { x: e.clientX, y: e.clientY };
                setTransform(prev => ({ ...prev, x: prev.x + dx, y: prev.y + dy }));
            };

            useEffect(() => {
                if (visualData.nodes.length > 0 && diagramRef.current) {
                    const render = async () => {
                        try {
                            let activeEdgeIndex = null;
                            let activeLabel = null;

                            if (status !== 'ACCEPTED' && status !== 'REJECTED') {
                                const currentSymbol = tape[head] || '_';
                                const key = `${currentState}:${currentSymbol}`;
                                const rule = transitions[key];
                                if (rule) {
                                    activeLabel = rule.label;
                                    activeEdgeIndex = rule.edgeIndex;
                                }
                            }
                            
                            const mermaidDef = generateMermaidDefinition(
                                visualData.nodes, 
                                visualData.edges, 
                                currentState, 
                                status, 
                                activeEdgeIndex 
                            );

                            diagramRef.current.removeAttribute('data-processed');
                            const { svg } = await mermaid.render('mermaid-svg-' + Date.now(), mermaidDef);
                            diagramRef.current.innerHTML = svg;
                            applySvgPostProcessing(diagramRef.current, THEME.primary, activeEdgeIndex, activeLabel);

                        } catch (e) {
                            console.error("Mermaid:", e);
                        }
                    };
                    render();
                }
            }, [visualData, currentState, status, tape, head, transitions]);

            return (
                <div className="flex-1 flex flex-col bg-slate-50/50 relative overflow-hidden">
                    <div 
                        className="flex-1 overflow-hidden relative cursor-grab active:cursor-grabbing bg-fixed touch-none select-none"
                        style={{ backgroundImage: 'radial-gradient(#cbd5e1 1px, transparent 1px)', backgroundSize: '24px 24px' }}
                        onWheel={handleWheel} onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp}
                        ref={containerRef}
                    >
                        <div className="absolute origin-top-left transition-transform duration-75 ease-out flex items-center justify-center w-full h-full" style={{ transform: `translate(${transform.x}px, ${transform.y}px) scale(${transform.scale})` }}>
                            {compileError ? (
                                <div className="bg-white/90 backdrop-blur-md p-6 rounded-2xl border border-rose-200 shadow-xl max-w-md text-center">
                                    <div className="text-rose-500 mb-2 flex justify-center"><Icons.AlertCircle size={32}/></div>
                                    <h3 className="text-rose-700 font-bold mb-1">Erro de Compilação</h3>
                                    <p className="text-rose-600/80 text-sm font-mono break-words">{compileError}</p>
                                </div>
                            ) : <div ref={diagramRef} className="origin-center" />}
                            {visualData.nodes.length === 0 && !compileError && <div className="text-slate-300 flex flex-col items-center"><Icons.Cpu size={48} className="mb-3 opacity-20"/><p className="font-medium">Sem diagrama.</p></div>}
                        </div>
                    </div>
                </div>
            );
        };

        const PlaybackControls = ({ onStepBack, onStepForward, onPlayPause, status, speed, setSpeed, historyLength }) => (
            <div className="absolute bottom-8 left-1/2 -translate-x-1/2 z-30">
                <div className="bg-white/90 backdrop-blur-xl border border-white/40 shadow-[0_8px_32px_rgba(99,102,241,0.15)] rounded-2xl p-2 px-6 flex items-center gap-6 ring-1 ring-slate-900/5">
                    <div className="flex items-center gap-3 border-r border-slate-200/60 pr-6 py-1">
                        <button onClick={onStepBack} disabled={historyLength === 0 || status === 'RUNNING'} aria-label="Passo Anterior" className="p-2.5 text-slate-400 hover:text-indigo-600 hover:bg-indigo-50 rounded-full disabled:opacity-30 transition-all"><Icons.SkipBack size={20} /></button>
                        <button onClick={onPlayPause} disabled={status === 'ACCEPTED' || status === 'REJECTED'} aria-label={status === 'RUNNING' ? "Pausar" : "Executar"} className={`w-14 h-14 flex items-center justify-center rounded-2xl shadow-lg transition-all active:scale-95 border-b-4 ${status === 'RUNNING' ? 'bg-amber-100 text-amber-600 border-amber-200 hover:bg-amber-200' : 'bg-indigo-600 text-white border-indigo-800 hover:bg-indigo-700'} disabled:opacity-50 disabled:grayscale disabled:border-transparent disabled:shadow-none`}>
                            {status === 'RUNNING' ? <Icons.Pause size={28} fill="currentColor"/> : <Icons.Play size={28} fill="currentColor" className="ml-1"/>}
                        </button>
                        <button onClick={onStepForward} disabled={status === 'RUNNING' || status === 'ACCEPTED' || status === 'REJECTED'} aria-label="Próximo Passo" className="p-2.5 text-slate-400 hover:text-indigo-600 hover:bg-indigo-50 rounded-full disabled:opacity-30 transition-all"><Icons.SkipForward size={20} /></button>
                    </div>
                    <div className="flex flex-col w-36 gap-1.5">
                        <div className="flex justify-between text-[9px] text-slate-400 font-bold uppercase tracking-widest"><span>Lento</span><span>Rápido</span></div>
                        <div className="relative h-4 flex items-center">
                            <input type="range" min="0" max="950" step="50" value={speed} onChange={(e) => setSpeed(Number(e.target.value))} aria-label="Controle de Velocidade" className="w-full h-1.5 bg-slate-200 rounded-full appearance-none cursor-pointer accent-indigo-600" />
                        </div>
                    </div>
                </div>
            </div>
        );

        const TuringMachineSimulator = () => {
            const [editorCode, setEditorCode] = useState(DEFAULT_CODE);
            const [isDirty, setIsDirty] = useState(false);
            
            // Estado de Visualização
            const [isEditorOpen, setIsEditorOpen] = useState(true);
            const [isTestsOpen, setIsTestsOpen] = useState(true);

            // Simulação
            const [tape, setTape] = useState({});
            const [head, setHead] = useState(0);
            const [currentState, setCurrentState] = useState('q0');
            const [status, setStatus] = useState('IDLE');
            const [stepCount, setStepCount] = useState(0);
            const [runtimeError, setRuntimeError] = useState(null);
            const [history, setHistory] = useState([]);
            
            // Controle
            const [activeInput, setActiveInput] = useState('10110');
            const [speed, setSpeed] = useState(500);
            const [transitions, setTransitions] = useState({});
            const [visualData, setVisualData] = useState({ nodes: [], edges: [] });
            const [compileError, setCompileError] = useState(null);

            // Test Suite State
            const [tests, setTests] = useState([
                { id: 1, input: '10110', status: 'IDLE' },
                { id: 2, input: '00000', status: 'IDLE' },
                { id: 3, input: '11111', status: 'IDLE' }
            ]);
            const [isRunningBatch, setIsRunningBatch] = useState(false);

            useEffect(() => {
                mermaid.initialize({ startOnLoad: false, theme: 'base', flowchart: { curve: 'basis', htmlLabels: false } });
                compileAndReset(); 
            }, []); 

            const handleEditorChange = useCallback((val) => { setEditorCode(val); setIsDirty(true); }, []);

            const loadTape = useCallback((inputVal) => {
                const initialTape = {};
                for (let i = 0; i < inputVal.length; i++) initialTape[i] = inputVal[i];
                setTape(initialTape);
                setHead(0);
                setStepCount(0);
                setCurrentState('q0');
                setHistory([]);
                setStatus('IDLE');
                setRuntimeError(null);
            }, []);

            const compileAndReset = useCallback(() => {
                try {
                    const { newTransitions, nodes, edges } = parseMachineCode(editorCode);
                    if (nodes.length === 0) throw new Error("Nenhum estado válido encontrado.");
                    setTransitions(newTransitions);
                    setVisualData({ nodes, edges });
                    setCompileError(null);
                    setIsDirty(false);
                    loadTape(activeInput);
                } catch (err) {
                    setCompileError(err.message);
                    setVisualData({ nodes: [], edges: [] });
                    setIsDirty(false); 
                }
            }, [editorCode, activeInput, loadTape]);

            const handleLoadTest = (inputVal) => {
                setActiveInput(inputVal);
                loadTape(inputVal);
            };

            const handleAddTest = () => {
                setTests(prev => [...prev, { id: Date.now(), input: '', status: 'IDLE' }]);
            };

            const handleRemoveTest = (id) => {
                setTests(prev => prev.filter(t => t.id !== id));
            };

            const handleUpdateTestInput = (id, val) => {
                setTests(prev => prev.map(t => t.id === id ? { ...t, input: val, status: 'IDLE' } : t));
            };

            const handleRunTests = () => {
                setIsRunningBatch(true);
                setTimeout(() => {
                    setTests(prev => prev.map(test => {
                        const result = runFastSimulation(transitions, test.input);
                        return { ...test, status: result };
                    }));
                    setIsRunningBatch(false);
                }, 100);
            };

            const handleCellClick = useCallback((index) => {
                // Se estiver rodando, para. Reseta para o índice clicado e estado q0.
                setStatus('IDLE');
                setHead(index);
                setCurrentState('q0');
                setStepCount(0);
                setRuntimeError(null);
                setHistory([]); 
            }, []);

            const stepForward = useCallback(() => {
                if (status === 'ACCEPTED' || status === 'REJECTED') return;
                const currentSymbol = tape[head] || '_';
                const key = `${currentState}:${currentSymbol}`;
                const rule = transitions[key];
                const historyState = { tape: { ...tape }, head, currentState, status, stepCount };

                if (!rule) {
                    if (currentState === 'ha') setStatus('ACCEPTED');
                    else {
                        setStatus('REJECTED');
                        setRuntimeError(`Sem transição para (${currentState}, ${currentSymbol})`);
                    }
                    setHistory(prev => [...prev.slice(-CONFIG.MAX_HISTORY), historyState]);
                    return;
                }

                const newTape = { ...tape };
                if (rule.write === '_') delete newTape[head];
                else newTape[head] = rule.write;

                let newHead = head;
                if (rule.move === 'R') newHead++;
                else if (rule.move === 'L') newHead--;

                if (newHead < 0) {
                    setStatus('REJECTED');
                    setRuntimeError("Crash: Limite esquerdo da fita.");
                    setHistory(prev => [...prev.slice(-CONFIG.MAX_HISTORY), historyState]);
                    return;
                }

                setTape(newTape);
                setHead(newHead);
                setStepCount(c => c + 1);
                setCurrentState(rule.to);
                setHistory(prev => [...prev.slice(-CONFIG.MAX_HISTORY), historyState]);

                if (rule.to === 'ha') setStatus('ACCEPTED');
            }, [tape, head, currentState, status, transitions, stepCount]);

            const stepBack = useCallback(() => {
                if (history.length === 0) return;
                const prev = history[history.length - 1];
                setTape(prev.tape);
                setHead(prev.head);
                setCurrentState(prev.currentState);
                setStepCount(prev.stepCount);
                setStatus('PAUSED');
                setRuntimeError(null);
                setHistory(prev => prev.slice(0, -1));
            }, [history]);

            useEffect(() => {
                let interval;
                if (status === 'RUNNING') {
                    const delay = 1000 - speed;
                    interval = setInterval(stepForward, Math.max(50, delay));
                }
                return () => clearInterval(interval);
            }, [status, speed, stepForward]);

            return (
                <div className="flex flex-col h-screen w-screen bg-white">
                    <Header status={status} runtimeError={runtimeError} currentState={currentState} head={head} stepCount={stepCount} activeInput={activeInput} />
                    <TapeVisualizer tape={tape} head={head} status={status} onCellClick={handleCellClick} />
                    
                    <div className="flex flex-1 overflow-hidden">
                        <EditorPanel 
                            editorCode={editorCode} 
                            setEditorCode={handleEditorChange} 
                            onCompile={compileAndReset}
                            isDirty={isDirty}
                            compileError={compileError}
                            isOpen={isEditorOpen}
                            onToggle={() => setIsEditorOpen(!isEditorOpen)}
                            status={status}
                        />
                        
                        <div className="flex-1 flex flex-col relative overflow-hidden bg-slate-50/50 border-r border-slate-200 transition-all duration-300" style={{ flexGrow: (isEditorOpen && isTestsOpen) ? 2 : 4 }}>
                            <DiagramVisualizer 
                                visualData={visualData} 
                                currentState={currentState} 
                                tape={tape} 
                                head={head} 
                                transitions={transitions} 
                                status={status} 
                                compileError={compileError}
                            />
                            <PlaybackControls 
                                onStepBack={stepBack} 
                                onStepForward={stepForward} 
                                onPlayPause={() => setStatus(s => s === 'RUNNING' ? 'PAUSED' : 'RUNNING')} 
                                status={status} 
                                speed={speed} 
                                setSpeed={setSpeed} 
                                historyLength={history.length}
                            />
                        </div>

                        <TestPanel 
                            tests={tests}
                            onAddTest={handleAddTest}
                            onRemoveTest={handleRemoveTest}
                            onUpdateTestInput={handleUpdateTestInput}
                            onRunTests={handleRunTests}
                            onLoadTest={handleLoadTest}
                            isRunningBatch={isRunningBatch}
                            isOpen={isTestsOpen}
                            onToggle={() => setIsTestsOpen(!isTestsOpen)}
                        />
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<TuringMachineSimulator />);
    </script>
</body>
</html>